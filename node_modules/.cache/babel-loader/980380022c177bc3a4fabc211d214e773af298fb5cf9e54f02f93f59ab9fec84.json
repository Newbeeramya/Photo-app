{"ast":null,"code":"import React, { forwardRef, useRef, useEffect, useCallback, useLayoutEffect, useState } from 'react';\n\n/** Container for clipped item. */\n\nconst ContainerClip = /*#__PURE__*/forwardRef((props, ref) => {\n  const style = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    willChange: 'clip',\n    userSelect: 'none',\n    KhtmlUserSelect: 'none',\n    MozUserSelect: 'none',\n    WebkitUserSelect: 'none'\n  };\n  return React.createElement(\"div\", Object.assign({}, props, {\n    style: style,\n    \"data-rcs\": \"clip-item\",\n    ref: ref\n  }));\n});\nContainerClip.displayName = 'ContainerClip';\n/** Container to control the handle's position. */\n\nconst ContainerHandle = /*#__PURE__*/forwardRef(({\n  children,\n  portrait\n}, ref) => {\n  const style = {\n    position: 'absolute',\n    top: 0,\n    width: '100%',\n    height: '100%',\n    pointerEvents: 'none'\n  };\n  const innerStyle = {\n    position: 'absolute',\n    width: portrait ? '100%' : undefined,\n    height: portrait ? undefined : '100%',\n    transform: portrait ? 'translateY(-50%)' : 'translateX(-50%)',\n    pointerEvents: 'all'\n  };\n  return React.createElement(\"div\", {\n    style: style,\n    \"data-rcs\": \"handle-container\",\n    ref: ref\n  }, React.createElement(\"div\", {\n    style: innerStyle\n  }, children));\n});\nContainerHandle.displayName = 'ThisHandleContainer';\nconst ThisArrow = ({\n  flip\n}) => {\n  const style = {\n    width: 0,\n    height: 0,\n    borderTop: '8px solid transparent',\n    borderRight: '10px solid',\n    borderBottom: '8px solid transparent',\n    transform: flip ? 'rotate(180deg)' : undefined\n  };\n  return React.createElement(\"div\", {\n    style: style\n  });\n};\n/** Default `handle`. */\n\nconst ReactCompareSliderHandle = ({\n  portrait,\n  buttonStyle,\n  linesStyle,\n  style,\n  ...props\n}) => {\n  const _style = {\n    display: 'flex',\n    flexDirection: portrait ? 'row' : 'column',\n    placeItems: 'center',\n    height: '100%',\n    cursor: portrait ? 'ns-resize' : 'ew-resize',\n    pointerEvents: 'none',\n    color: '#fff',\n    ...style\n  };\n  const _linesStyle = {\n    flexGrow: 1,\n    height: portrait ? 2 : '100%',\n    width: portrait ? '100%' : 2,\n    backgroundColor: 'currentColor',\n    pointerEvents: 'auto',\n    boxShadow: '0 0 7px rgba(0,0,0,.35)',\n    ...linesStyle\n  };\n  const _buttonStyle = {\n    display: 'grid',\n    gridAutoFlow: 'column',\n    gap: 8,\n    placeContent: 'center',\n    flexShrink: 0,\n    width: 56,\n    height: 56,\n    borderRadius: '50%',\n    borderStyle: 'solid',\n    borderWidth: 2,\n    pointerEvents: 'auto',\n    backdropFilter: 'blur(7px)',\n    WebkitBackdropFilter: 'blur(7px)',\n    boxShadow: '0 0 7px rgba(0,0,0,.35)',\n    transform: portrait ? 'rotate(90deg)' : undefined,\n    ...buttonStyle\n  };\n  return React.createElement(\"div\", Object.assign({\n    className: \"__rcs-handle-root\"\n  }, props, {\n    style: _style\n  }), React.createElement(\"div\", {\n    className: \"__rcs-handle-line\",\n    style: _linesStyle\n  }), React.createElement(\"div\", {\n    className: \"__rcs-handle-button\",\n    style: _buttonStyle\n  }, React.createElement(ThisArrow, null), React.createElement(ThisArrow, {\n    flip: true\n  })), React.createElement(\"div\", {\n    className: \"__rcs-handle-line\",\n    style: _linesStyle\n  }));\n};\n\n/**\r\n * Stand-alone CSS utility to make replaced elements (`img`, `video`, etc.) fit their\r\n * container.\r\n */\n\nconst styleFitContainer = ({\n  boxSizing = 'border-box',\n  objectFit = 'cover',\n  objectPosition = 'center',\n  ...props\n} = {}) => ({\n  display: 'block',\n  width: '100%',\n  height: '100%',\n  maxWidth: '100%',\n  boxSizing,\n  objectFit,\n  objectPosition,\n  ...props\n});\n/** Store the previous supplied value. */\n\nconst usePrevious = value => {\n  const ref = useRef(value);\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n};\n/**\r\n * Event listener binding hook.\r\n * @param eventName      - Event to bind to.\r\n * @param handler        - Callback handler.\r\n * @param element        - Element to bind to.\r\n * @param handlerOptions - Event handler options.\r\n */\n\nconst useEventListener = (eventName, handler, element, handlerOptions) => {\n  const savedHandler = useRef();\n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n  useEffect(() => {\n    // Make sure element supports addEventListener.\n    if (!(element && element.addEventListener)) return; // Create event listener that calls handler function stored in ref.\n\n    const eventListener = event => savedHandler.current && savedHandler.current(event);\n    element.addEventListener(eventName, eventListener, handlerOptions);\n    return () => {\n      element.removeEventListener(eventName, eventListener, handlerOptions);\n    };\n  }, [eventName, element, handlerOptions]);\n};\n/**\r\n * Conditionally use `useLayoutEffect` for client *or* `useEffect` for SSR.\r\n * @see <https://github.com/reduxjs/react-redux/blob/c581d480dd675f2645851fb006bef91aeb6ac24d/src/utils/useIsomorphicLayoutEffect.js>\r\n */\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' && window.document && window.document.createElement ? useLayoutEffect : useEffect;\n/**\r\n * Bind resize observer callback to element.\r\n * @param ref       - Element to bind to.\r\n * @param handler   - Callback for handling entry's bounding rect.\r\n */\n\nconst useResizeObserver = (ref, handler) => {\n  const observer = useRef();\n  const observe = useCallback(() => {\n    if (ref.current && observer.current) observer.current.observe(ref.current);\n  }, [ref]); // Bind/rebind observer when `handler` changes.\n\n  useIsomorphicLayoutEffect(() => {\n    observer.current = new ResizeObserver(([entry]) => handler(entry.contentRect));\n    observe();\n    return () => {\n      if (observer.current) observer.current.disconnect();\n    };\n  }, [handler, observe]);\n};\nconst EVENT_PASSIVE_PARAMS = {\n  passive: true\n};\nconst EVENT_CAPTURE_PARAMS = {\n  capture: true,\n  passive: false\n};\n/** Root Comparison slider. */\n\nconst ReactCompareSlider = ({\n  handle,\n  itemOne,\n  itemTwo,\n  onlyHandleDraggable = false,\n  onPositionChange,\n  portrait = false,\n  position = 50,\n  boundsPadding = 0,\n  changePositionOnHover = false,\n  style,\n  ...props\n}) => {\n  /** DOM node of the root element. */\n  const rootContainerRef = useRef(null);\n  /** DOM node of the item that is clipped. */\n\n  const clipContainerRef = useRef(null);\n  /** DOM node of the handle container. */\n\n  const handleContainerRef = useRef(null);\n  /** Current position as a percentage value (initially negative to sync bounds on mount). */\n\n  const internalPositionPc = useRef(position);\n  /** Previous `position` prop value. */\n\n  const prevPropPosition = usePrevious(position);\n  /** Whether user is currently dragging. */\n\n  const [isDragging, setIsDragging] = useState(false);\n  /** Whether component has a `window` event binding. */\n\n  const hasWindowBinding = useRef(false);\n  /** Target container for pointer events. */\n\n  const [interactiveTarget, setInteractiveTarget] = useState();\n  /** Whether the bounds of the container element have been synchronised. */\n\n  const [didSyncBounds, setDidSyncBounds] = useState(false); // Set target container for pointer events.\n\n  useEffect(() => {\n    setInteractiveTarget(onlyHandleDraggable ? handleContainerRef.current : rootContainerRef.current);\n  }, [onlyHandleDraggable]);\n  /** Update internal position value. */\n\n  const updateInternalPosition = useCallback(function updateInternalCall({\n    x,\n    y,\n    isOffset,\n    portrait: _portrait,\n    boundsPadding: _boundsPadding\n  }) {\n    const {\n      top,\n      left,\n      width,\n      height\n    } = rootContainerRef.current.getBoundingClientRect(); // Early out if width or height are zero, can't calculate values\n    // from zeros.\n\n    if (width === 0 || height === 0) return;\n    /**\r\n     * Pixel position clamped within the container's bounds.\r\n     * @NOTE This does *not* take `boundsPadding` into account because we need\r\n     *       the full coords to correctly position the handle.\r\n     */\n\n    const positionPx = Math.min(Math.max(\n    // Determine bounds based on orientation\n    _portrait ? isOffset ? y - top - window.pageYOffset : y : isOffset ? x - left - window.pageXOffset : x,\n    // Min value\n    0),\n    // Max value\n    _portrait ? height : width);\n    /** Width or height with CSS scaling accounted for. */\n\n    const zoomScale = _portrait ? height / (rootContainerRef.current.offsetHeight || 1) : width / (rootContainerRef.current.offsetWidth || 1);\n    const adjustedPosition = positionPx / zoomScale;\n    const adjustedWidth = width / zoomScale;\n    const adjustedHeight = height / zoomScale;\n    /**\r\n     * Internal position percentage *without* bounds.\r\n     * @NOTE This uses the entire container bounds **without** `boundsPadding`\r\n     *       to get the *real* bounds.\r\n     */\n\n    const nextInternalPositionPc = adjustedPosition / (_portrait ? adjustedHeight : adjustedWidth) * 100;\n    /** Whether the current pixel position meets the min/max bounds. */\n\n    const positionMeetsBounds = _portrait ? adjustedPosition === 0 || adjustedPosition === adjustedHeight : adjustedPosition === 0 || adjustedPosition === adjustedWidth;\n    const canSkipPositionPc = nextInternalPositionPc === internalPositionPc.current && (internalPositionPc.current === 0 || internalPositionPc.current === 100); // Early out if pixel and percentage positions are already at the min/max\n    // to prevent update spamming when the user is sliding outside of the\n    // container.\n\n    if (didSyncBounds && canSkipPositionPc && positionMeetsBounds) {\n      return;\n    } else {\n      setDidSyncBounds(true);\n    } // Set new internal position.\n\n    internalPositionPc.current = nextInternalPositionPc;\n    /** Pixel position clamped to extremities *with* bounds padding. */\n\n    const clampedPx = Math.min(\n    // Get largest from pixel position *or* bounds padding.\n    Math.max(adjustedPosition, 0 + _boundsPadding),\n    // Use height *or* width based on orientation.\n    (_portrait ? adjustedHeight : adjustedWidth) - _boundsPadding);\n    clipContainerRef.current.style.clip = _portrait ? `rect(auto,auto,${clampedPx}px,auto)` : `rect(auto,${clampedPx}px,auto,auto)`;\n    handleContainerRef.current.style.transform = _portrait ? `translate3d(0,${clampedPx}px,0)` : `translate3d(${clampedPx}px,0,0)`;\n    if (onPositionChange) onPositionChange(internalPositionPc.current);\n  }, [didSyncBounds, onPositionChange]); // Update internal position when other user controllable props change.\n\n  useEffect(() => {\n    const {\n      width,\n      height\n    } = rootContainerRef.current.getBoundingClientRect(); // Use current internal position if `position` hasn't changed.\n\n    const nextPosition = position === prevPropPosition ? internalPositionPc.current : position;\n    updateInternalPosition({\n      portrait,\n      boundsPadding,\n      x: width / 100 * nextPosition,\n      y: height / 100 * nextPosition\n    });\n  }, [portrait, position, prevPropPosition, boundsPadding, updateInternalPosition]);\n  /** Handle mouse/touch down. */\n\n  const handlePointerDown = useCallback(ev => {\n    ev.preventDefault();\n    updateInternalPosition({\n      portrait,\n      boundsPadding,\n      isOffset: true,\n      x: ev instanceof MouseEvent ? ev.pageX : ev.touches[0].pageX,\n      y: ev instanceof MouseEvent ? ev.pageY : ev.touches[0].pageY\n    });\n    setIsDragging(true);\n  }, [portrait, boundsPadding, updateInternalPosition]);\n  /** Handle mouse/touch move. */\n\n  const handlePointerMove = useCallback(function moveCall(ev) {\n    updateInternalPosition({\n      portrait,\n      boundsPadding,\n      isOffset: true,\n      x: ev instanceof MouseEvent ? ev.pageX : ev.touches[0].pageX,\n      y: ev instanceof MouseEvent ? ev.pageY : ev.touches[0].pageY\n    });\n  }, [portrait, boundsPadding, updateInternalPosition]);\n  /** Handle mouse/touch up. */\n\n  const handlePointerUp = useCallback(() => {\n    setIsDragging(false);\n  }, []);\n  /** Resync internal position on resize. */\n\n  const handleResize = useCallback(({\n    width,\n    height\n  }) => {\n    const {\n      width: scaledWidth,\n      height: scaledHeight\n    } = rootContainerRef.current.getBoundingClientRect();\n    updateInternalPosition({\n      portrait,\n      boundsPadding,\n      x: width / 100 * internalPositionPc.current * scaledWidth / width,\n      y: height / 100 * internalPositionPc.current * scaledHeight / height\n    });\n  }, [portrait, boundsPadding, updateInternalPosition]); // Allow drag outside of container while pointer is still down.\n\n  useEffect(() => {\n    if (isDragging && !hasWindowBinding.current) {\n      window.addEventListener('mousemove', handlePointerMove, EVENT_PASSIVE_PARAMS);\n      window.addEventListener('mouseup', handlePointerUp, EVENT_PASSIVE_PARAMS);\n      window.addEventListener('touchmove', handlePointerMove, EVENT_PASSIVE_PARAMS);\n      window.addEventListener('touchend', handlePointerUp, EVENT_PASSIVE_PARAMS);\n      hasWindowBinding.current = true;\n    }\n    return () => {\n      if (hasWindowBinding.current) {\n        window.removeEventListener('mousemove', handlePointerMove);\n        window.removeEventListener('mouseup', handlePointerUp);\n        window.removeEventListener('touchmove', handlePointerMove);\n        window.removeEventListener('touchend', handlePointerUp);\n        hasWindowBinding.current = false;\n      }\n    };\n  }, [handlePointerMove, handlePointerUp, isDragging]); // Bind resize observer to container.\n\n  useResizeObserver(rootContainerRef, handleResize); // Handle hover events on the container.\n\n  useEffect(() => {\n    const containerRef = rootContainerRef.current;\n    const handleMouseLeave = () => {\n      if (isDragging) return;\n      handlePointerUp();\n    };\n    if (changePositionOnHover) {\n      containerRef.addEventListener('mousemove', handlePointerMove, EVENT_PASSIVE_PARAMS);\n      containerRef.addEventListener('mouseleave', handleMouseLeave, EVENT_PASSIVE_PARAMS);\n    }\n    return () => {\n      containerRef.removeEventListener('mousemove', handlePointerMove);\n      containerRef.removeEventListener('mouseleave', handleMouseLeave);\n    };\n  }, [changePositionOnHover, handlePointerMove, handlePointerUp, isDragging]);\n  useEventListener('mousedown', handlePointerDown, interactiveTarget, EVENT_CAPTURE_PARAMS);\n  useEventListener('touchstart', handlePointerDown, interactiveTarget, EVENT_CAPTURE_PARAMS); // Use custom handle if requested.\n\n  const Handle = handle || React.createElement(ReactCompareSliderHandle, {\n    portrait: portrait\n  });\n  const rootStyle = {\n    position: 'relative',\n    overflow: 'hidden',\n    cursor: isDragging ? portrait ? 'ns-resize' : 'ew-resize' : undefined,\n    userSelect: 'none',\n    KhtmlUserSelect: 'none',\n    msUserSelect: 'none',\n    MozUserSelect: 'none',\n    WebkitUserSelect: 'none',\n    ...style\n  };\n  return React.createElement(\"div\", Object.assign({}, props, {\n    ref: rootContainerRef,\n    style: rootStyle,\n    \"data-rcs\": \"root\"\n  }), itemTwo, React.createElement(ContainerClip, {\n    ref: clipContainerRef\n  }, itemOne), React.createElement(ContainerHandle, {\n    portrait: portrait,\n    ref: handleContainerRef\n  }, Handle));\n};\n\n/** Image with defaults from `styleFitContainer` applied. */\n\nconst ReactCompareSliderImage = ({\n  style,\n  ...props\n}) => {\n  const rootStyle = styleFitContainer(style);\n  return React.createElement(\"img\", Object.assign({}, props, {\n    style: rootStyle,\n    \"data-rcs\": \"image\"\n  }));\n};\nexport { ReactCompareSlider, ReactCompareSliderHandle, ReactCompareSliderImage, styleFitContainer };","map":{"version":3,"names":["ContainerClip","forwardRef","props","ref","style","position","top","left","width","height","willChange","userSelect","KhtmlUserSelect","MozUserSelect","WebkitUserSelect","React","createElement","Object","assign","displayName","ContainerHandle","children","portrait","pointerEvents","innerStyle","undefined","transform","ThisArrow","flip","borderTop","borderRight","borderBottom","ReactCompareSliderHandle","buttonStyle","linesStyle","_style","display","flexDirection","placeItems","cursor","color","_linesStyle","flexGrow","backgroundColor","boxShadow","_buttonStyle","gridAutoFlow","gap","placeContent","flexShrink","borderRadius","borderStyle","borderWidth","backdropFilter","WebkitBackdropFilter","className","styleFitContainer","boxSizing","objectFit","objectPosition","maxWidth","usePrevious","value","useRef","useEffect","current","useEventListener","eventName","handler","element","handlerOptions","savedHandler","addEventListener","eventListener","event","removeEventListener","useIsomorphicLayoutEffect","window","document","useLayoutEffect","useResizeObserver","observer","observe","useCallback","ResizeObserver","entry","contentRect","disconnect","EVENT_PASSIVE_PARAMS","passive","EVENT_CAPTURE_PARAMS","capture","ReactCompareSlider","handle","itemOne","itemTwo","onlyHandleDraggable","onPositionChange","boundsPadding","changePositionOnHover","rootContainerRef","clipContainerRef","handleContainerRef","internalPositionPc","prevPropPosition","isDragging","setIsDragging","useState","hasWindowBinding","interactiveTarget","setInteractiveTarget","didSyncBounds","setDidSyncBounds","updateInternalPosition","updateInternalCall","x","y","isOffset","_portrait","_boundsPadding","getBoundingClientRect","positionPx","Math","min","max","pageYOffset","pageXOffset","zoomScale","offsetHeight","offsetWidth","adjustedPosition","adjustedWidth","adjustedHeight","nextInternalPositionPc","positionMeetsBounds","canSkipPositionPc","clampedPx","clip","nextPosition","handlePointerDown","ev","preventDefault","MouseEvent","pageX","touches","pageY","handlePointerMove","moveCall","handlePointerUp","handleResize","scaledWidth","scaledHeight","containerRef","handleMouseLeave","Handle","rootStyle","overflow","msUserSelect","ReactCompareSliderImage"],"sources":["C:\\Users\\ADMIN\\OneDrive\\Desktop\\ramya\\photo app\\node_modules\\react-compare-slider\\src\\Container.tsx","C:\\Users\\ADMIN\\OneDrive\\Desktop\\ramya\\photo app\\node_modules\\react-compare-slider\\src\\ReactCompareSliderHandle.tsx","C:\\Users\\ADMIN\\OneDrive\\Desktop\\ramya\\photo app\\node_modules\\react-compare-slider\\src\\utils.ts","C:\\Users\\ADMIN\\OneDrive\\Desktop\\ramya\\photo app\\node_modules\\react-compare-slider\\src\\ReactCompareSlider.tsx","C:\\Users\\ADMIN\\OneDrive\\Desktop\\ramya\\photo app\\node_modules\\react-compare-slider\\src\\ReactCompareSliderImage.tsx"],"sourcesContent":["import React, { forwardRef } from 'react';\n\nimport type { ReactCompareSliderCommonProps } from './types';\n\n/** Container for clipped item. */\nexport const ContainerClip = forwardRef<HTMLDivElement, React.HTMLProps<HTMLDivElement>>(\n  (props, ref): React.ReactElement => {\n    const style: React.CSSProperties = {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      willChange: 'clip',\n      userSelect: 'none',\n      KhtmlUserSelect: 'none',\n      MozUserSelect: 'none',\n      WebkitUserSelect: 'none',\n    };\n\n    return <div {...props} style={style} data-rcs=\"clip-item\" ref={ref} />;\n  }\n);\n\nContainerClip.displayName = 'ContainerClip';\n\n/** Container to control the handle's position. */\nexport const ContainerHandle = forwardRef<\n  HTMLDivElement,\n  React.HTMLProps<HTMLDivElement> & Pick<ReactCompareSliderCommonProps, 'portrait'>\n>(\n  ({ children, portrait }, ref): React.ReactElement => {\n    const style: React.CSSProperties = {\n      position: 'absolute',\n      top: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n    };\n\n    const innerStyle: React.CSSProperties = {\n      position: 'absolute',\n      width: portrait ? '100%' : undefined,\n      height: portrait ? undefined : '100%',\n      transform: portrait ? 'translateY(-50%)' : 'translateX(-50%)',\n      pointerEvents: 'all',\n    };\n\n    return (\n      <div style={style} data-rcs=\"handle-container\" ref={ref}>\n        <div style={innerStyle}>{children}</div>\n      </div>\n    );\n  }\n);\n\nContainerHandle.displayName = 'ThisHandleContainer';\n","import React from 'react';\n\nimport { ReactCompareSliderCommonProps } from './types';\n\ninterface ThisArrowProps {\n  /** Whether to flip the arrow direction. */\n  flip?: boolean;\n}\n\nconst ThisArrow: React.FC<ThisArrowProps> = ({ flip }) => {\n  const style: React.CSSProperties = {\n    width: 0,\n    height: 0,\n    borderTop: '8px solid transparent',\n    borderRight: '10px solid',\n    borderBottom: '8px solid transparent',\n    transform: flip ? 'rotate(180deg)' : undefined,\n  };\n\n  return <div style={style} />;\n};\n\n/** Props for `ReactCompareSliderHandle`. */\nexport interface ReactCompareSliderHandleProps\n  extends Pick<ReactCompareSliderCommonProps, 'portrait'> {\n  /** Optional styles for handle the button. */\n  buttonStyle?: React.CSSProperties;\n  /** Optional styles for lines either side of the handle button. */\n  linesStyle?: React.CSSProperties;\n  /** Optional styles for the handle root. */\n  style?: React.CSSProperties;\n}\n\n/** Default `handle`. */\nexport const ReactCompareSliderHandle: React.FC<ReactCompareSliderHandleProps> = ({\n  portrait,\n  buttonStyle,\n  linesStyle,\n  style,\n  ...props\n}): React.ReactElement => {\n  const _style: React.CSSProperties = {\n    display: 'flex',\n    flexDirection: portrait ? 'row' : 'column',\n    placeItems: 'center',\n    height: '100%',\n    cursor: portrait ? 'ns-resize' : 'ew-resize',\n    pointerEvents: 'none',\n    color: '#fff',\n    ...style,\n  };\n\n  const _linesStyle: React.CSSProperties = {\n    flexGrow: 1,\n    height: portrait ? 2 : '100%',\n    width: portrait ? '100%' : 2,\n    backgroundColor: 'currentColor',\n    pointerEvents: 'auto',\n    boxShadow: '0 0 7px rgba(0,0,0,.35)',\n    ...linesStyle,\n  };\n\n  const _buttonStyle: React.CSSProperties = {\n    display: 'grid',\n    gridAutoFlow: 'column',\n    gap: 8,\n    placeContent: 'center',\n    flexShrink: 0,\n    width: 56,\n    height: 56,\n    borderRadius: '50%',\n    borderStyle: 'solid',\n    borderWidth: 2,\n    pointerEvents: 'auto',\n    backdropFilter: 'blur(7px)',\n    WebkitBackdropFilter: 'blur(7px)', // For Safari.\n    boxShadow: '0 0 7px rgba(0,0,0,.35)',\n    transform: portrait ? 'rotate(90deg)' : undefined,\n    ...buttonStyle,\n  };\n\n  return (\n    <div className=\"__rcs-handle-root\" {...props} style={_style}>\n      <div className=\"__rcs-handle-line\" style={_linesStyle} />\n      <div className=\"__rcs-handle-button\" style={_buttonStyle}>\n        <ThisArrow />\n        <ThisArrow flip />\n      </div>\n      <div className=\"__rcs-handle-line\" style={_linesStyle} />\n    </div>\n  );\n};\n","import { RefObject, useCallback, useEffect, useLayoutEffect, useRef } from 'react';\n\n/**\n * Stand-alone CSS utility to make replaced elements (`img`, `video`, etc.) fit their\n * container.\n */\nexport const styleFitContainer = ({\n  boxSizing = 'border-box',\n  objectFit = 'cover',\n  objectPosition = 'center',\n  ...props\n}: React.CSSProperties = {}): React.CSSProperties => ({\n  display: 'block',\n  width: '100%',\n  height: '100%',\n  maxWidth: '100%',\n  boxSizing,\n  objectFit,\n  objectPosition,\n  ...props,\n});\n\n/** Store the previous supplied value. */\nexport const usePrevious = <T>(value: T): T => {\n  const ref = useRef<T>(value);\n\n  useEffect(() => {\n    ref.current = value;\n  });\n\n  return ref.current;\n};\n\n/**\n * Event listener binding hook.\n * @param eventName      - Event to bind to.\n * @param handler        - Callback handler.\n * @param element        - Element to bind to.\n * @param handlerOptions - Event handler options.\n */\nexport const useEventListener = (\n  eventName: EventListener['name'],\n  handler: EventListener['caller'],\n  element: EventTarget,\n  handlerOptions: AddEventListenerOptions\n): void => {\n  const savedHandler = useRef<EventListener['caller']>();\n\n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n\n  useEffect(() => {\n    // Make sure element supports addEventListener.\n    if (!(element && element.addEventListener)) return;\n\n    // Create event listener that calls handler function stored in ref.\n    const eventListener: EventListener = (event) =>\n      savedHandler.current && savedHandler.current(event);\n\n    element.addEventListener(eventName, eventListener, handlerOptions);\n\n    return (): void => {\n      element.removeEventListener(eventName, eventListener, handlerOptions);\n    };\n  }, [eventName, element, handlerOptions]);\n};\n\n/**\n * Conditionally use `useLayoutEffect` for client *or* `useEffect` for SSR.\n * @see <https://github.com/reduxjs/react-redux/blob/c581d480dd675f2645851fb006bef91aeb6ac24d/src/utils/useIsomorphicLayoutEffect.js>\n */\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' && window.document && window.document.createElement\n    ? useLayoutEffect\n    : useEffect;\n\n/** Params passed to `useResizeObserver` `handler` function. */\nexport type UseResizeObserverHandlerParams = DOMRect;\n\n/**\n * Bind resize observer callback to element.\n * @param ref       - Element to bind to.\n * @param handler   - Callback for handling entry's bounding rect.\n */\nexport const useResizeObserver = (\n  ref: RefObject<Element>,\n  handler: (entry: UseResizeObserverHandlerParams) => void\n): void => {\n  const observer = useRef<ResizeObserver>();\n\n  const observe = useCallback(() => {\n    if (ref.current && observer.current) observer.current.observe(ref.current);\n  }, [ref]);\n\n  // Bind/rebind observer when `handler` changes.\n  useIsomorphicLayoutEffect(() => {\n    observer.current = new ResizeObserver(([entry]) => handler(entry.contentRect));\n    observe();\n\n    return (): void => {\n      if (observer.current) observer.current.disconnect();\n    };\n  }, [handler, observe]);\n};\n","import React, { useEffect, useCallback, useRef, useState } from 'react';\n\nimport { ContainerClip, ContainerHandle } from './Container';\nimport { ReactCompareSliderHandle } from './ReactCompareSliderHandle';\nimport { ReactCompareSliderCommonProps, ReactCompareSliderPropPosition } from './types';\nimport {\n  useEventListener,\n  usePrevious,\n  UseResizeObserverHandlerParams,\n  useResizeObserver,\n} from './utils';\n\n/** Comparison slider properties. */\nexport interface ReactCompareSliderProps extends Partial<ReactCompareSliderCommonProps> {\n  /** Padding to limit the slideable bounds in pixels on the X-axis (landscape) or Y-axis (portrait). */\n  boundsPadding?: number;\n  /** Whether the slider should follow the pointer on hover. */\n  changePositionOnHover?: boolean;\n  /** Custom handle component. */\n  handle?: React.ReactNode;\n  /** First item to show. */\n  itemOne: React.ReactNode;\n  /** Second item to show. */\n  itemTwo: React.ReactNode;\n  /** Whether to only change position when handle is interacted with (useful for touch devices). */\n  onlyHandleDraggable?: boolean;\n  /** Callback on position change with position as percentage. */\n  onPositionChange?: (position: ReactCompareSliderPropPosition) => void;\n}\n\n/** Properties for internal `updateInternalPosition` callback. */\ninterface UpdateInternalPositionProps\n  extends Required<Pick<ReactCompareSliderProps, 'boundsPadding' | 'portrait'>> {\n  /** X coordinate to update to (landscape). */\n  x: number;\n  /** Y coordinate to update to (portrait). */\n  y: number;\n  /** Whether to calculate using page X and Y offsets (required for pointer events). */\n  isOffset?: boolean;\n}\n\nconst EVENT_PASSIVE_PARAMS = { passive: true };\nconst EVENT_CAPTURE_PARAMS = { capture: true, passive: false };\n\n/** Root Comparison slider. */\nexport const ReactCompareSlider: React.FC<\n  ReactCompareSliderProps & React.HtmlHTMLAttributes<HTMLDivElement>\n> = ({\n  handle,\n  itemOne,\n  itemTwo,\n  onlyHandleDraggable = false,\n  onPositionChange,\n  portrait = false,\n  position = 50,\n  boundsPadding = 0,\n  changePositionOnHover = false,\n  style,\n  ...props\n}): React.ReactElement => {\n  /** DOM node of the root element. */\n  const rootContainerRef = useRef<HTMLDivElement>(null);\n  /** DOM node of the item that is clipped. */\n  const clipContainerRef = useRef<HTMLDivElement>(null);\n  /** DOM node of the handle container. */\n  const handleContainerRef = useRef<HTMLDivElement>(null);\n  /** Current position as a percentage value (initially negative to sync bounds on mount). */\n  const internalPositionPc = useRef(position);\n  /** Previous `position` prop value. */\n  const prevPropPosition = usePrevious(position);\n  /** Whether user is currently dragging. */\n  const [isDragging, setIsDragging] = useState(false);\n  /** Whether component has a `window` event binding. */\n  const hasWindowBinding = useRef(false);\n  /** Target container for pointer events. */\n  const [interactiveTarget, setInteractiveTarget] = useState<HTMLDivElement | null>();\n  /** Whether the bounds of the container element have been synchronised. */\n  const [didSyncBounds, setDidSyncBounds] = useState(false);\n\n  // Set target container for pointer events.\n  useEffect(() => {\n    setInteractiveTarget(\n      onlyHandleDraggable ? handleContainerRef.current : rootContainerRef.current\n    );\n  }, [onlyHandleDraggable]);\n\n  /** Update internal position value. */\n  const updateInternalPosition = useCallback(\n    function updateInternalCall({\n      x,\n      y,\n      isOffset,\n      portrait: _portrait,\n      boundsPadding: _boundsPadding,\n    }: UpdateInternalPositionProps) {\n      const { top, left, width, height } = (\n        rootContainerRef.current as HTMLDivElement\n      ).getBoundingClientRect();\n\n      // Early out if width or height are zero, can't calculate values\n      // from zeros.\n      if (width === 0 || height === 0) return;\n\n      /**\n       * Pixel position clamped within the container's bounds.\n       * @NOTE This does *not* take `boundsPadding` into account because we need\n       *       the full coords to correctly position the handle.\n       */\n      const positionPx = Math.min(\n        Math.max(\n          // Determine bounds based on orientation\n          _portrait\n            ? isOffset\n              ? y - top - window.pageYOffset\n              : y\n            : isOffset\n            ? x - left - window.pageXOffset\n            : x,\n          // Min value\n          0\n        ),\n        // Max value\n        _portrait ? height : width\n      );\n\n      /** Width or height with CSS scaling accounted for. */\n      const zoomScale = _portrait\n        ? height / ((rootContainerRef.current as HTMLDivElement).offsetHeight || 1)\n        : width / ((rootContainerRef.current as HTMLDivElement).offsetWidth || 1);\n\n      const adjustedPosition = positionPx / zoomScale;\n      const adjustedWidth = width / zoomScale;\n      const adjustedHeight = height / zoomScale;\n\n      /**\n       * Internal position percentage *without* bounds.\n       * @NOTE This uses the entire container bounds **without** `boundsPadding`\n       *       to get the *real* bounds.\n       */\n      const nextInternalPositionPc =\n        (adjustedPosition / (_portrait ? adjustedHeight : adjustedWidth)) * 100;\n\n      /** Whether the current pixel position meets the min/max bounds. */\n      const positionMeetsBounds = _portrait\n        ? adjustedPosition === 0 || adjustedPosition === adjustedHeight\n        : adjustedPosition === 0 || adjustedPosition === adjustedWidth;\n\n      const canSkipPositionPc =\n        nextInternalPositionPc === internalPositionPc.current &&\n        (internalPositionPc.current === 0 || internalPositionPc.current === 100);\n\n      // Early out if pixel and percentage positions are already at the min/max\n      // to prevent update spamming when the user is sliding outside of the\n      // container.\n      if (didSyncBounds && canSkipPositionPc && positionMeetsBounds) {\n        return;\n      } else {\n        setDidSyncBounds(true);\n      }\n\n      // Set new internal position.\n      internalPositionPc.current = nextInternalPositionPc;\n\n      /** Pixel position clamped to extremities *with* bounds padding. */\n      const clampedPx = Math.min(\n        // Get largest from pixel position *or* bounds padding.\n        Math.max(adjustedPosition, 0 + _boundsPadding),\n        // Use height *or* width based on orientation.\n        (_portrait ? adjustedHeight : adjustedWidth) - _boundsPadding\n      );\n\n      (clipContainerRef.current as HTMLElement).style.clip = _portrait\n        ? `rect(auto,auto,${clampedPx}px,auto)`\n        : `rect(auto,${clampedPx}px,auto,auto)`;\n\n      (handleContainerRef.current as HTMLElement).style.transform = _portrait\n        ? `translate3d(0,${clampedPx}px,0)`\n        : `translate3d(${clampedPx}px,0,0)`;\n\n      if (onPositionChange) onPositionChange(internalPositionPc.current);\n    },\n    [didSyncBounds, onPositionChange]\n  );\n\n  // Update internal position when other user controllable props change.\n  useEffect(() => {\n    const { width, height } = (\n      rootContainerRef.current as HTMLDivElement\n    ).getBoundingClientRect();\n\n    // Use current internal position if `position` hasn't changed.\n    const nextPosition =\n      position === prevPropPosition ? internalPositionPc.current : position;\n\n    updateInternalPosition({\n      portrait,\n      boundsPadding,\n      x: (width / 100) * nextPosition,\n      y: (height / 100) * nextPosition,\n    });\n  }, [portrait, position, prevPropPosition, boundsPadding, updateInternalPosition]);\n\n  /** Handle mouse/touch down. */\n  const handlePointerDown = useCallback(\n    (ev: MouseEvent | TouchEvent) => {\n      ev.preventDefault();\n\n      updateInternalPosition({\n        portrait,\n        boundsPadding,\n        isOffset: true,\n        x: ev instanceof MouseEvent ? ev.pageX : ev.touches[0].pageX,\n        y: ev instanceof MouseEvent ? ev.pageY : ev.touches[0].pageY,\n      });\n\n      setIsDragging(true);\n    },\n    [portrait, boundsPadding, updateInternalPosition]\n  );\n\n  /** Handle mouse/touch move. */\n  const handlePointerMove = useCallback(\n    function moveCall(ev: MouseEvent | TouchEvent) {\n      updateInternalPosition({\n        portrait,\n        boundsPadding,\n        isOffset: true,\n        x: ev instanceof MouseEvent ? ev.pageX : ev.touches[0].pageX,\n        y: ev instanceof MouseEvent ? ev.pageY : ev.touches[0].pageY,\n      });\n    },\n    [portrait, boundsPadding, updateInternalPosition]\n  );\n\n  /** Handle mouse/touch up. */\n  const handlePointerUp = useCallback(() => {\n    setIsDragging(false);\n  }, []);\n\n  /** Resync internal position on resize. */\n  const handleResize: (resizeProps: UseResizeObserverHandlerParams) => void = useCallback(\n    ({ width, height }) => {\n      const { width: scaledWidth, height: scaledHeight } = (\n        rootContainerRef.current as HTMLDivElement\n      ).getBoundingClientRect();\n\n      updateInternalPosition({\n        portrait,\n        boundsPadding,\n        x: ((width / 100) * internalPositionPc.current * scaledWidth) / width,\n        y: ((height / 100) * internalPositionPc.current * scaledHeight) / height,\n      });\n    },\n    [portrait, boundsPadding, updateInternalPosition]\n  );\n\n  // Allow drag outside of container while pointer is still down.\n  useEffect(() => {\n    if (isDragging && !hasWindowBinding.current) {\n      window.addEventListener('mousemove', handlePointerMove, EVENT_PASSIVE_PARAMS);\n      window.addEventListener('mouseup', handlePointerUp, EVENT_PASSIVE_PARAMS);\n      window.addEventListener('touchmove', handlePointerMove, EVENT_PASSIVE_PARAMS);\n      window.addEventListener('touchend', handlePointerUp, EVENT_PASSIVE_PARAMS);\n      hasWindowBinding.current = true;\n    }\n\n    return (): void => {\n      if (hasWindowBinding.current) {\n        window.removeEventListener('mousemove', handlePointerMove);\n        window.removeEventListener('mouseup', handlePointerUp);\n        window.removeEventListener('touchmove', handlePointerMove);\n        window.removeEventListener('touchend', handlePointerUp);\n        hasWindowBinding.current = false;\n      }\n    };\n  }, [handlePointerMove, handlePointerUp, isDragging]);\n\n  // Bind resize observer to container.\n  useResizeObserver(rootContainerRef, handleResize);\n\n  // Handle hover events on the container.\n  useEffect(() => {\n    const containerRef = rootContainerRef.current as HTMLDivElement;\n\n    const handleMouseLeave = () => {\n      if (isDragging) return;\n      handlePointerUp();\n    };\n\n    if (changePositionOnHover) {\n      containerRef.addEventListener('mousemove', handlePointerMove, EVENT_PASSIVE_PARAMS);\n      containerRef.addEventListener('mouseleave', handleMouseLeave, EVENT_PASSIVE_PARAMS);\n    }\n\n    return () => {\n      containerRef.removeEventListener('mousemove', handlePointerMove);\n      containerRef.removeEventListener('mouseleave', handleMouseLeave);\n    };\n  }, [changePositionOnHover, handlePointerMove, handlePointerUp, isDragging]);\n\n  useEventListener(\n    'mousedown',\n    handlePointerDown,\n    interactiveTarget as HTMLDivElement,\n    EVENT_CAPTURE_PARAMS\n  );\n\n  useEventListener(\n    'touchstart',\n    handlePointerDown,\n    interactiveTarget as HTMLDivElement,\n    EVENT_CAPTURE_PARAMS\n  );\n\n  // Use custom handle if requested.\n  const Handle = handle || <ReactCompareSliderHandle portrait={portrait} />;\n\n  const rootStyle: React.CSSProperties = {\n    position: 'relative',\n    overflow: 'hidden',\n    cursor: isDragging ? (portrait ? 'ns-resize' : 'ew-resize') : undefined,\n    userSelect: 'none',\n    KhtmlUserSelect: 'none',\n    msUserSelect: 'none',\n    MozUserSelect: 'none',\n    WebkitUserSelect: 'none',\n    ...style,\n  };\n\n  return (\n    <div {...props} ref={rootContainerRef} style={rootStyle} data-rcs=\"root\">\n      {itemTwo}\n      <ContainerClip ref={clipContainerRef}>{itemOne}</ContainerClip>\n      <ContainerHandle portrait={portrait} ref={handleContainerRef}>\n        {Handle}\n      </ContainerHandle>\n    </div>\n  );\n};\n","import React from 'react';\n\nimport { styleFitContainer } from './utils';\n\n/** Props for `ReactCompareSliderImage`. */\nexport type ReactCompareSliderImageProps = React.ImgHTMLAttributes<HTMLImageElement>;\n\n/** Image with defaults from `styleFitContainer` applied. */\nexport const ReactCompareSliderImage: React.FC<ReactCompareSliderImageProps> = ({\n  style,\n  ...props\n}): React.ReactElement => {\n  const rootStyle: React.CSSProperties = styleFitContainer(style);\n\n  return <img {...props} style={rootStyle} data-rcs=\"image\" />;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}