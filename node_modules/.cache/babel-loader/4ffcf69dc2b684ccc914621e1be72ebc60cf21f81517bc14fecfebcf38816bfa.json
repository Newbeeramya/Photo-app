{"ast":null,"code":"// Image processing utilities for perspective correction and document detection\nimport cv from 'opencv.js';\nclass ImageProcessor {\n  constructor() {\n    this.isOpenCVReady = false;\n    this.initOpenCV();\n  }\n  async initOpenCV() {\n    return new Promise(resolve => {\n      if (typeof cv !== 'undefined' && cv.Mat) {\n        this.isOpenCVReady = true;\n        resolve();\n        return;\n      }\n\n      // Wait for OpenCV to load\n      const checkOpenCV = () => {\n        if (typeof cv !== 'undefined' && cv.Mat) {\n          this.isOpenCVReady = true;\n          resolve();\n        } else {\n          setTimeout(checkOpenCV, 100);\n        }\n      };\n      checkOpenCV();\n    });\n  }\n\n  // Convert image file to OpenCV Mat\n  async fileToMat(file) {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      img.onload = () => {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        canvas.width = img.width;\n        canvas.height = img.height;\n        ctx.drawImage(img, 0, 0);\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        const mat = cv.matFromImageData(imageData);\n        resolve(mat);\n      };\n      img.onerror = reject;\n      img.src = URL.createObjectURL(file);\n    });\n  }\n\n  // Convert OpenCV Mat to canvas\n  matToCanvas(mat, canvasId) {\n    cv.imshow(canvasId, mat);\n  }\n\n  // Detect document edges using contour detection\n  detectDocumentEdges(src) {\n    const gray = new cv.Mat();\n    const blur = new cv.Mat();\n    const edges = new cv.Mat();\n    const contours = new cv.MatVector();\n    const hierarchy = new cv.Mat();\n    try {\n      // Convert to grayscale\n      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);\n\n      // Apply Gaussian blur to reduce noise\n      cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);\n\n      // Edge detection using Canny\n      cv.Canny(blur, edges, 50, 150);\n\n      // Find contours\n      cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);\n      let maxArea = 0;\n      let bestContour = null;\n\n      // Find the largest rectangular contour\n      for (let i = 0; i < contours.size(); i++) {\n        const contour = contours.get(i);\n        const area = cv.contourArea(contour);\n        if (area > maxArea && area > src.rows * src.cols * 0.1) {\n          // Approximate contour to polygon\n          const epsilon = 0.02 * cv.arcLength(contour, true);\n          const approx = new cv.Mat();\n          cv.approxPolyDP(contour, approx, epsilon, true);\n\n          // Check if it's roughly rectangular (4 corners)\n          if (approx.rows === 4) {\n            maxArea = area;\n            if (bestContour) bestContour.delete();\n            bestContour = approx.clone();\n          }\n          approx.delete();\n        }\n        contour.delete();\n      }\n\n      // Clean up\n      gray.delete();\n      blur.delete();\n      edges.delete();\n      contours.delete();\n      hierarchy.delete();\n      return bestContour;\n    } catch (error) {\n      console.error('Error in document edge detection:', error);\n      // Clean up on error\n      [gray, blur, edges, contours, hierarchy].forEach(mat => {\n        try {\n          mat.delete();\n        } catch (e) {}\n      });\n      return null;\n    }\n  }\n\n  // Extract corner points from contour\n  getCornerPoints(contour) {\n    if (!contour || contour.rows !== 4) return null;\n    const points = [];\n    for (let i = 0; i < 4; i++) {\n      const point = contour.data32S.slice(i * 2, i * 2 + 2);\n      points.push({\n        x: point[0],\n        y: point[1]\n      });\n    }\n\n    // Sort points: top-left, top-right, bottom-right, bottom-left\n    points.sort((a, b) => a.y - b.y);\n    const top = points.slice(0, 2).sort((a, b) => a.x - b.x);\n    const bottom = points.slice(2, 4).sort((a, b) => a.x - b.x);\n    return {\n      topLeft: top[0],\n      topRight: top[1],\n      bottomLeft: bottom[0],\n      bottomRight: bottom[1]\n    };\n  }\n\n  // Apply perspective transformation\n  correctPerspective(src, corners, outputWidth = 800, outputHeight = 1000) {\n    if (!corners) return src.clone();\n    const {\n      topLeft,\n      topRight,\n      bottomLeft,\n      bottomRight\n    } = corners;\n\n    // Source points (detected corners)\n    const srcPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [topLeft.x, topLeft.y, topRight.x, topRight.y, bottomRight.x, bottomRight.y, bottomLeft.x, bottomLeft.y]);\n\n    // Destination points (rectangle)\n    const dstPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, outputWidth, 0, outputWidth, outputHeight, 0, outputHeight]);\n\n    // Get perspective transform matrix\n    const transformMatrix = cv.getPerspectiveTransform(srcPoints, dstPoints);\n\n    // Apply transformation\n    const corrected = new cv.Mat();\n    cv.warpPerspective(src, corrected, transformMatrix, new cv.Size(outputWidth, outputHeight));\n\n    // Clean up\n    srcPoints.delete();\n    dstPoints.delete();\n    transformMatrix.delete();\n    return corrected;\n  }\n\n  // Auto-rotate image based on text orientation\n  autoRotate(src) {\n    const rotations = [0, 90, 180, 270];\n    let bestRotation = 0;\n    let bestScore = 0;\n    for (const angle of rotations) {\n      const rotated = this.rotateImage(src, angle);\n      const score = this.calculateTextOrientationScore(rotated);\n      if (score > bestScore) {\n        bestScore = score;\n        bestRotation = angle;\n      }\n      if (angle !== 0) rotated.delete();\n    }\n    if (bestRotation === 0) {\n      return src.clone();\n    } else {\n      return this.rotateImage(src, bestRotation);\n    }\n  }\n\n  // Rotate image by specified angle\n  rotateImage(src, angle) {\n    if (angle === 0) return src.clone();\n    const center = new cv.Point2f(src.cols / 2, src.rows / 2);\n    const rotationMatrix = cv.getRotationMatrix2D(center, angle, 1.0);\n    const rotated = new cv.Mat();\n    const size = angle % 180 === 0 ? new cv.Size(src.cols, src.rows) : new cv.Size(src.rows, src.cols);\n    cv.warpAffine(src, rotated, rotationMatrix, size);\n    rotationMatrix.delete();\n    return rotated;\n  }\n\n  // Calculate text orientation score (simplified heuristic)\n  calculateTextOrientationScore(src) {\n    const gray = new cv.Mat();\n    const edges = new cv.Mat();\n    try {\n      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);\n      cv.Canny(gray, edges, 50, 150);\n\n      // Count horizontal vs vertical edges\n      const horizontalKernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(25, 1));\n      const verticalKernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(1, 25));\n      const horizontal = new cv.Mat();\n      const vertical = new cv.Mat();\n      cv.morphologyEx(edges, horizontal, cv.MORPH_OPEN, horizontalKernel);\n      cv.morphologyEx(edges, vertical, cv.MORPH_OPEN, verticalKernel);\n      const horizontalSum = cv.sumElems(horizontal)[0];\n      const verticalSum = cv.sumElems(vertical)[0];\n\n      // Clean up\n      gray.delete();\n      edges.delete();\n      horizontalKernel.delete();\n      verticalKernel.delete();\n      horizontal.delete();\n      vertical.delete();\n\n      // Return ratio favoring horizontal lines (typical for text)\n      return horizontalSum / (verticalSum + 1);\n    } catch (error) {\n      console.error('Error calculating text orientation score:', error);\n      [gray, edges].forEach(mat => {\n        try {\n          mat.delete();\n        } catch (e) {}\n      });\n      return 0;\n    }\n  }\n\n  // Enhance image quality (contrast, brightness, sharpening)\n  enhanceQuality(src, intensity = 'medium') {\n    const enhanced = src.clone();\n    try {\n      // Adjust contrast and brightness based on intensity\n      const alpha = intensity === 'low' ? 1.1 : intensity === 'high' ? 1.4 : 1.25;\n      const beta = intensity === 'low' ? 5 : intensity === 'high' ? 15 : 10;\n      enhanced.convertTo(enhanced, -1, alpha, beta);\n\n      // Apply sharpening filter\n      const kernel = cv.matFromArray(3, 3, cv.CV_32FC1, [0, -1, 0, -1, 5, -1, 0, -1, 0]);\n      const sharpened = new cv.Mat();\n      cv.filter2D(enhanced, sharpened, -1, kernel);\n      kernel.delete();\n      enhanced.delete();\n      return sharpened;\n    } catch (error) {\n      console.error('Error enhancing image quality:', error);\n      return enhanced;\n    }\n  }\n\n  // Remove noise from image\n  removeNoise(src) {\n    const denoised = new cv.Mat();\n    try {\n      // Apply bilateral filter to reduce noise while preserving edges\n      cv.bilateralFilter(src, denoised, 9, 75, 75);\n      return denoised;\n    } catch (error) {\n      console.error('Error removing noise:', error);\n      denoised.delete();\n      return src.clone();\n    }\n  }\n\n  // Main processing function\n  async processDocument(file, options = {}) {\n    const {\n      autoCorrectPerspective = true,\n      autoRotate = true,\n      enhanceQuality = true,\n      removeNoise = true,\n      intensity = 'medium'\n    } = options;\n    if (!this.isOpenCVReady) {\n      await this.initOpenCV();\n    }\n    try {\n      // Load image\n      const src = await this.fileToMat(file);\n      let processed = src.clone();\n\n      // Step 1: Auto-rotate if enabled\n      if (autoRotate) {\n        const rotated = this.autoRotate(processed);\n        processed.delete();\n        processed = rotated;\n      }\n\n      // Step 2: Perspective correction if enabled\n      if (autoCorrectPerspective) {\n        const contour = this.detectDocumentEdges(processed);\n        if (contour) {\n          const corners = this.getCornerPoints(contour);\n          if (corners) {\n            const corrected = this.correctPerspective(processed, corners);\n            processed.delete();\n            processed = corrected;\n          }\n          contour.delete();\n        }\n      }\n\n      // Step 3: Remove noise if enabled\n      if (removeNoise) {\n        const denoised = this.removeNoise(processed);\n        processed.delete();\n        processed = denoised;\n      }\n\n      // Step 4: Enhance quality if enabled\n      if (enhanceQuality) {\n        const enhanced = this.enhanceQuality(processed, intensity);\n        processed.delete();\n        processed = enhanced;\n      }\n\n      // Convert back to canvas/blob\n      const canvas = document.createElement('canvas');\n      canvas.width = processed.cols;\n      canvas.height = processed.rows;\n      cv.imshow(canvas, processed);\n\n      // Clean up\n      src.delete();\n      processed.delete();\n\n      // Convert canvas to blob\n      return new Promise(resolve => {\n        canvas.toBlob(blob => {\n          const enhancedFile = new File([blob], `enhanced_${file.name}`, {\n            type: file.type,\n            lastModified: Date.now()\n          });\n          resolve(enhancedFile);\n        }, file.type, 0.95);\n      });\n    } catch (error) {\n      console.error('Error processing document:', error);\n      throw new Error('Failed to process document: ' + error.message);\n    }\n  }\n}\n\n// Export singleton instance\nexport default new ImageProcessor();","map":{"version":3,"names":["cv","ImageProcessor","constructor","isOpenCVReady","initOpenCV","Promise","resolve","Mat","checkOpenCV","setTimeout","fileToMat","file","reject","img","Image","onload","canvas","document","createElement","ctx","getContext","width","height","drawImage","imageData","getImageData","mat","matFromImageData","onerror","src","URL","createObjectURL","matToCanvas","canvasId","imshow","detectDocumentEdges","gray","blur","edges","contours","MatVector","hierarchy","cvtColor","COLOR_RGBA2GRAY","GaussianBlur","Size","Canny","findContours","RETR_EXTERNAL","CHAIN_APPROX_SIMPLE","maxArea","bestContour","i","size","contour","get","area","contourArea","rows","cols","epsilon","arcLength","approx","approxPolyDP","delete","clone","error","console","forEach","e","getCornerPoints","points","point","data32S","slice","push","x","y","sort","a","b","top","bottom","topLeft","topRight","bottomLeft","bottomRight","correctPerspective","corners","outputWidth","outputHeight","srcPoints","matFromArray","CV_32FC2","dstPoints","transformMatrix","getPerspectiveTransform","corrected","warpPerspective","autoRotate","rotations","bestRotation","bestScore","angle","rotated","rotateImage","score","calculateTextOrientationScore","center","Point2f","rotationMatrix","getRotationMatrix2D","warpAffine","horizontalKernel","getStructuringElement","MORPH_RECT","verticalKernel","horizontal","vertical","morphologyEx","MORPH_OPEN","horizontalSum","sumElems","verticalSum","enhanceQuality","intensity","enhanced","alpha","beta","convertTo","kernel","CV_32FC1","sharpened","filter2D","removeNoise","denoised","bilateralFilter","processDocument","options","autoCorrectPerspective","processed","toBlob","blob","enhancedFile","File","name","type","lastModified","Date","now","Error","message"],"sources":["C:/Users/ADMIN/OneDrive/Desktop/ramya/photo app/src/utils/imageProcessor.js"],"sourcesContent":["// Image processing utilities for perspective correction and document detection\nimport cv from 'opencv.js';\n\nclass ImageProcessor {\n  constructor() {\n    this.isOpenCVReady = false;\n    this.initOpenCV();\n  }\n\n  async initOpenCV() {\n    return new Promise((resolve) => {\n      if (typeof cv !== 'undefined' && cv.Mat) {\n        this.isOpenCVReady = true;\n        resolve();\n        return;\n      }\n\n      // Wait for OpenCV to load\n      const checkOpenCV = () => {\n        if (typeof cv !== 'undefined' && cv.Mat) {\n          this.isOpenCVReady = true;\n          resolve();\n        } else {\n          setTimeout(checkOpenCV, 100);\n        }\n      };\n      checkOpenCV();\n    });\n  }\n\n  // Convert image file to OpenCV Mat\n  async fileToMat(file) {\n    return new Promise((resolve, reject) => {\n      const img = new Image();\n      img.onload = () => {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        canvas.width = img.width;\n        canvas.height = img.height;\n        ctx.drawImage(img, 0, 0);\n        \n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        const mat = cv.matFromImageData(imageData);\n        resolve(mat);\n      };\n      img.onerror = reject;\n      img.src = URL.createObjectURL(file);\n    });\n  }\n\n  // Convert OpenCV Mat to canvas\n  matToCanvas(mat, canvasId) {\n    cv.imshow(canvasId, mat);\n  }\n\n  // Detect document edges using contour detection\n  detectDocumentEdges(src) {\n    const gray = new cv.Mat();\n    const blur = new cv.Mat();\n    const edges = new cv.Mat();\n    const contours = new cv.MatVector();\n    const hierarchy = new cv.Mat();\n\n    try {\n      // Convert to grayscale\n      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);\n      \n      // Apply Gaussian blur to reduce noise\n      cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);\n      \n      // Edge detection using Canny\n      cv.Canny(blur, edges, 50, 150);\n      \n      // Find contours\n      cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);\n      \n      let maxArea = 0;\n      let bestContour = null;\n      \n      // Find the largest rectangular contour\n      for (let i = 0; i < contours.size(); i++) {\n        const contour = contours.get(i);\n        const area = cv.contourArea(contour);\n        \n        if (area > maxArea && area > src.rows * src.cols * 0.1) {\n          // Approximate contour to polygon\n          const epsilon = 0.02 * cv.arcLength(contour, true);\n          const approx = new cv.Mat();\n          cv.approxPolyDP(contour, approx, epsilon, true);\n          \n          // Check if it's roughly rectangular (4 corners)\n          if (approx.rows === 4) {\n            maxArea = area;\n            if (bestContour) bestContour.delete();\n            bestContour = approx.clone();\n          }\n          approx.delete();\n        }\n        contour.delete();\n      }\n      \n      // Clean up\n      gray.delete();\n      blur.delete();\n      edges.delete();\n      contours.delete();\n      hierarchy.delete();\n      \n      return bestContour;\n    } catch (error) {\n      console.error('Error in document edge detection:', error);\n      // Clean up on error\n      [gray, blur, edges, contours, hierarchy].forEach(mat => {\n        try { mat.delete(); } catch (e) {}\n      });\n      return null;\n    }\n  }\n\n  // Extract corner points from contour\n  getCornerPoints(contour) {\n    if (!contour || contour.rows !== 4) return null;\n\n    const points = [];\n    for (let i = 0; i < 4; i++) {\n      const point = contour.data32S.slice(i * 2, i * 2 + 2);\n      points.push({ x: point[0], y: point[1] });\n    }\n\n    // Sort points: top-left, top-right, bottom-right, bottom-left\n    points.sort((a, b) => a.y - b.y);\n    \n    const top = points.slice(0, 2).sort((a, b) => a.x - b.x);\n    const bottom = points.slice(2, 4).sort((a, b) => a.x - b.x);\n    \n    return {\n      topLeft: top[0],\n      topRight: top[1],\n      bottomLeft: bottom[0],\n      bottomRight: bottom[1]\n    };\n  }\n\n  // Apply perspective transformation\n  correctPerspective(src, corners, outputWidth = 800, outputHeight = 1000) {\n    if (!corners) return src.clone();\n\n    const { topLeft, topRight, bottomLeft, bottomRight } = corners;\n    \n    // Source points (detected corners)\n    const srcPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [\n      topLeft.x, topLeft.y,\n      topRight.x, topRight.y,\n      bottomRight.x, bottomRight.y,\n      bottomLeft.x, bottomLeft.y\n    ]);\n    \n    // Destination points (rectangle)\n    const dstPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [\n      0, 0,\n      outputWidth, 0,\n      outputWidth, outputHeight,\n      0, outputHeight\n    ]);\n    \n    // Get perspective transform matrix\n    const transformMatrix = cv.getPerspectiveTransform(srcPoints, dstPoints);\n    \n    // Apply transformation\n    const corrected = new cv.Mat();\n    cv.warpPerspective(src, corrected, transformMatrix, new cv.Size(outputWidth, outputHeight));\n    \n    // Clean up\n    srcPoints.delete();\n    dstPoints.delete();\n    transformMatrix.delete();\n    \n    return corrected;\n  }\n\n  // Auto-rotate image based on text orientation\n  autoRotate(src) {\n    const rotations = [0, 90, 180, 270];\n    let bestRotation = 0;\n    let bestScore = 0;\n\n    for (const angle of rotations) {\n      const rotated = this.rotateImage(src, angle);\n      const score = this.calculateTextOrientationScore(rotated);\n      \n      if (score > bestScore) {\n        bestScore = score;\n        bestRotation = angle;\n      }\n      \n      if (angle !== 0) rotated.delete();\n    }\n\n    if (bestRotation === 0) {\n      return src.clone();\n    } else {\n      return this.rotateImage(src, bestRotation);\n    }\n  }\n\n  // Rotate image by specified angle\n  rotateImage(src, angle) {\n    if (angle === 0) return src.clone();\n\n    const center = new cv.Point2f(src.cols / 2, src.rows / 2);\n    const rotationMatrix = cv.getRotationMatrix2D(center, angle, 1.0);\n    \n    const rotated = new cv.Mat();\n    const size = angle % 180 === 0 \n      ? new cv.Size(src.cols, src.rows)\n      : new cv.Size(src.rows, src.cols);\n    \n    cv.warpAffine(src, rotated, rotationMatrix, size);\n    \n    rotationMatrix.delete();\n    return rotated;\n  }\n\n  // Calculate text orientation score (simplified heuristic)\n  calculateTextOrientationScore(src) {\n    const gray = new cv.Mat();\n    const edges = new cv.Mat();\n    \n    try {\n      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);\n      cv.Canny(gray, edges, 50, 150);\n      \n      // Count horizontal vs vertical edges\n      const horizontalKernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(25, 1));\n      const verticalKernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(1, 25));\n      \n      const horizontal = new cv.Mat();\n      const vertical = new cv.Mat();\n      \n      cv.morphologyEx(edges, horizontal, cv.MORPH_OPEN, horizontalKernel);\n      cv.morphologyEx(edges, vertical, cv.MORPH_OPEN, verticalKernel);\n      \n      const horizontalSum = cv.sumElems(horizontal)[0];\n      const verticalSum = cv.sumElems(vertical)[0];\n      \n      // Clean up\n      gray.delete();\n      edges.delete();\n      horizontalKernel.delete();\n      verticalKernel.delete();\n      horizontal.delete();\n      vertical.delete();\n      \n      // Return ratio favoring horizontal lines (typical for text)\n      return horizontalSum / (verticalSum + 1);\n    } catch (error) {\n      console.error('Error calculating text orientation score:', error);\n      [gray, edges].forEach(mat => {\n        try { mat.delete(); } catch (e) {}\n      });\n      return 0;\n    }\n  }\n\n  // Enhance image quality (contrast, brightness, sharpening)\n  enhanceQuality(src, intensity = 'medium') {\n    const enhanced = src.clone();\n    \n    try {\n      // Adjust contrast and brightness based on intensity\n      const alpha = intensity === 'low' ? 1.1 : intensity === 'high' ? 1.4 : 1.25;\n      const beta = intensity === 'low' ? 5 : intensity === 'high' ? 15 : 10;\n      \n      enhanced.convertTo(enhanced, -1, alpha, beta);\n      \n      // Apply sharpening filter\n      const kernel = cv.matFromArray(3, 3, cv.CV_32FC1, [\n        0, -1, 0,\n        -1, 5, -1,\n        0, -1, 0\n      ]);\n      \n      const sharpened = new cv.Mat();\n      cv.filter2D(enhanced, sharpened, -1, kernel);\n      \n      kernel.delete();\n      enhanced.delete();\n      \n      return sharpened;\n    } catch (error) {\n      console.error('Error enhancing image quality:', error);\n      return enhanced;\n    }\n  }\n\n  // Remove noise from image\n  removeNoise(src) {\n    const denoised = new cv.Mat();\n    \n    try {\n      // Apply bilateral filter to reduce noise while preserving edges\n      cv.bilateralFilter(src, denoised, 9, 75, 75);\n      return denoised;\n    } catch (error) {\n      console.error('Error removing noise:', error);\n      denoised.delete();\n      return src.clone();\n    }\n  }\n\n  // Main processing function\n  async processDocument(file, options = {}) {\n    const {\n      autoCorrectPerspective = true,\n      autoRotate = true,\n      enhanceQuality = true,\n      removeNoise = true,\n      intensity = 'medium'\n    } = options;\n\n    if (!this.isOpenCVReady) {\n      await this.initOpenCV();\n    }\n\n    try {\n      // Load image\n      const src = await this.fileToMat(file);\n      let processed = src.clone();\n\n      // Step 1: Auto-rotate if enabled\n      if (autoRotate) {\n        const rotated = this.autoRotate(processed);\n        processed.delete();\n        processed = rotated;\n      }\n\n      // Step 2: Perspective correction if enabled\n      if (autoCorrectPerspective) {\n        const contour = this.detectDocumentEdges(processed);\n        if (contour) {\n          const corners = this.getCornerPoints(contour);\n          if (corners) {\n            const corrected = this.correctPerspective(processed, corners);\n            processed.delete();\n            processed = corrected;\n          }\n          contour.delete();\n        }\n      }\n\n      // Step 3: Remove noise if enabled\n      if (removeNoise) {\n        const denoised = this.removeNoise(processed);\n        processed.delete();\n        processed = denoised;\n      }\n\n      // Step 4: Enhance quality if enabled\n      if (enhanceQuality) {\n        const enhanced = this.enhanceQuality(processed, intensity);\n        processed.delete();\n        processed = enhanced;\n      }\n\n      // Convert back to canvas/blob\n      const canvas = document.createElement('canvas');\n      canvas.width = processed.cols;\n      canvas.height = processed.rows;\n      cv.imshow(canvas, processed);\n\n      // Clean up\n      src.delete();\n      processed.delete();\n\n      // Convert canvas to blob\n      return new Promise((resolve) => {\n        canvas.toBlob((blob) => {\n          const enhancedFile = new File([blob], `enhanced_${file.name}`, {\n            type: file.type,\n            lastModified: Date.now()\n          });\n          resolve(enhancedFile);\n        }, file.type, 0.95);\n      });\n\n    } catch (error) {\n      console.error('Error processing document:', error);\n      throw new Error('Failed to process document: ' + error.message);\n    }\n  }\n}\n\n// Export singleton instance\nexport default new ImageProcessor();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}